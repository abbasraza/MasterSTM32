# Path to CMSIS directory (Provided by ARM)
CMSIS = ../../CMSIS_5

# startup & system source files (Provided by STMicroelectronics)
SRCS += ../../cmsis_device_f4/Source/Templates/gcc/startup_stm32f429xx.s
SRCS += ../../cmsis_device_f4/Source/Templates/system_stm32f4xx.c

# Linker script file automatically generated by STM32CubeIDE
LINKER_SCRIPT = ../../linker_scripts/STM32F429ZITX_FLASH.ld

# Object files directory
OBJDIR = Debug

# Object files
OBJS := $(addprefix $(OBJDIR)/,$(notdir $(SRCS:.c=.o)))
OBJS := $(addprefix $(OBJDIR)/,$(notdir $(OBJS:.s=.o)))

# Search path for source files
vpath %.c $(sort $(dir $(SRCS)))
vpath %.s $(sort $(dir $(SRCS)))

# Include directories
INCLUDES += -I.
INCLUDES += -I../../cmsis_device_f4/Include
INCLUDES += -I$(CMSIS)/CMSIS/Core/Include


# Compiler flags
# Choose processor
CFLAGS += -DSTM32F429xx
CFLAGS += -mcpu=cortex-m4 -mthumb # processor setup
CFLAGS += -O0 # optimization is off
CFLAGS += -std=gnu11 # use GNU 11 standard

# ifeq ($(DEBUG), 1)
# CFLAGS += -g -gdwarf-2 # generate debug info
# # generate dependency info
# CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)" -MT"$(@:%.o=%.d)"
# endif

# # Disable the default behavior of allocating uninitialized global variables in the common section.
# CFLAGS += -fno-common

# Enable all warnings.
CFLAGS += -Wall

# Enable extra warnings not covered by -Wall.
CFLAGS += -Wextra

# Enable strict ISO warnings.
CFLAGS += -pedantic

# # Warn if a directory that should exist does not exist.
# CFLAGS += -Wmissing-include-dirs

# # Warn when comparing signed and unsigned integers.
# CFLAGS += -Wsign-compare

# # Warn when a pointer is cast to a more strictly aligned pointer type.
# CFLAGS += -Wcast-align

# # Warn when an integer constant expression with negative value is implicitly converted to unsigned type.
# CFLAGS += -Wconversion

# # Use single-precision constants instead of double-precision constants.
# CFLAGS += -fsingle-precision-constant

# # Omit the frame pointer if it is not needed.
# CFLAGS += -fomit-frame-pointer

# # Place each function or data item into its own section in the output file.
# CFLAGS += -ffunction-sections -fdata-sections

# Use the nano.specs file to link against the nano version of the C library.
CFLAGS += --specs=nano.specs

# Chooses the relevant FPU option
#CFLAGS += -mfloat-abi=soft # No FP
CFLAGS += -mfloat-abi=softfp -mfpu=fpv4-sp-d16 # Soft FP
#CFLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16 # Hard FP

# Linker flags
LDFLAGS += -mfloat-abi=softfp -mfpu=fpv4-sp-d16 # Use software floating point with single precision
#LDFLAGS += -mfloat-abi=hard -mfpu=fpv4-sp-d16 # Use hardware floating point with single precision

LDFLAGS += -mcpu=cortex-m4 -mthumb # Set the processor to Cortex-M4 and use Thumb mode
#LDFLAGS += -nostartfiles # Do not use standard start files
#LDFLAGS += -nodefaultlibs # Do not use standard libraries
#LDFLAGS += -nostdlib # Do not use startup or default libs
LDFLAGS += --specs=nosys.specs # Use no system calls
LDFLAGS += --specs=nano.specs # Use the nano version of the C library
#LDFLAGS += --specs=rdimon.specs # Use the rdimon version of the C library
LDFLAGS += -Wl,--gc-sections # Enable linker garbage collector
# LDFLAGS += -Wl,-Map=$(OBJDIR)/$(TARGET).map # Generate map file
# LDFLAGS += -Wl,--cref # Add symbols to map file
LDFLAGS += -T$(LINKER_SCRIPT) # Use the specified linker script
LDFLAGS += $(LIBINCLUDES) # Include library directories
LDFLAGS += $(LIBS) # Include libraries
# LDFLAGS += -lc # Link against the C library

# Cross-compilation tools
CROSS_COMPILE = arm-none-eabi-
CC = $(CROSS_COMPILE)gcc
LD = $(CROSS_COMPILE)ld
OBJDUMP = $(CROSS_COMPILE)objdump
OBJCOPY = $(CROSS_COMPILE)objcopy
SIZE = $(CROSS_COMPILE)size
DBG = $(CROSS_COMPILE)gdb

# Build targets
all: clean $(SRCS) build size
	@echo "Successfully finished..."

build: $(TARGET).elf $(TARGET).bin 
#$(TARGET).lst

# Link object files to create ELF file
$(TARGET).elf: $(OBJS)
	$(CC) $(OBJS) $(LDFLAGS) -o $(OBJDIR)/$@

# Compile C source files to object files
$(OBJDIR)/%.o: %.c
	@mkdir -p $(OBJDIR)
	@echo "Building" $<
	$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@

# Assemble assembly source files to object files
$(OBJDIR)/%.o: %.s
	@echo "Building" $<
	$(CC) $(CFLAGS) -c $< -o $@

# Convert ELF file to binary file
%.bin: %.elf
	@$(OBJCOPY) -O binary $(OBJDIR)/$< $(OBJDIR)/$@

# # Generate assembly listing file
# %.lst: %.elf
# 	@$(OBJDUMP) -x -S $(OBJDIR)/$(TARGET).elf > $(OBJDIR)/$@

# Flash binary file to target device
burn:
	@st-flash write $(OBJDIR)/$(TARGET).bin 0x8000000

# Clean object files directory
clean:
	@echo "Cleaning..."
	@rm -rf $(OBJDIR)/

# Phony targets
.PHONY: all build size clean burn debug disass disass-all
